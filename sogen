#!/usr/bin/env bash

state=head
head=()
tail=()
header=
footer=
helpindent=0

main() {
	i="$indent"

	local outfile=
	local line=

	if [ "$1" ]; then
		exec <"$1"
	fi

	parse

	if [[ "$e" ]]; then
		outfile="${1%.*}.sh"
		touch "$outfile"
		chmod +x "$outfile"
		exec >"$outfile"
	elif [[ "$executable" ]]; then
		touch "$executable"
		chmod +x "$executable"
		exec >"$executable"
	fi

	for line in "${head[@]}"; do
		echo "$line"
	done

	calc_helpindent

	cat <<-'EOF'
		################################################################################
		# Generated by sogen {

	EOF

	write_init
	echo
	write_help
	echo
	write_dump
	echo

	cat <<-'EOF'
		sogen_die() {
		    echo "ERROR: $1" >&2
		    echo >&2
		    sogen_help >&2
		    exit 1
		}
	EOF

	echo sogen_init
	echo
	write_parser
	cat <<-'EOF'

		# End of sogen-generated code }
		################################################################################
	EOF

	for line in "${tail[@]}"; do
		echo "$line"
	done
}

parse() {
	local idx=0 p_idx=0 h_idx=0 opts=() line= rest t o1 o2

	on_opt_entered "$(printf "%03i" "$idx")" "h help" # help option implied
	on_id "opt_$(printf "%03i" "$idx")" "sogen_help"
	on_help "opt_$(printf "%03i" "$idx")" "$(printf "%03i" $h_idx)" "help Display this help text and exit"

	idx=$(( $idx + 1 ));

	on_opt_entered "$(printf "%03i" "$idx")" "sogen-dump" # help option implied
	on_id "opt_$(printf "%03i" "$idx")" "sogen_dump"
	on_help "opt_$(printf "%03i" "$idx")" "$(printf "%03i" $h_idx)" "sogen_dump Dump arguments and exit"

	while IFS= read -r line; do
		t= rest= o1= o2=
		if [ "${line//\'/}" == '<<-@SOGEN' ] || [ "${line//\"/}" == '<<-@SOGEN' ] || [ "$line" == '@SOGEN' ]; then
			continue
		fi
		case $state in
			head)
				case "$line" in
					@sogenstart) state=sogen
						idx=$(( $idx + 1 ));
						;;
					*)
						head+=("$line") ;;
				esac ;;
			sogen)
				case "$line" in
					@sogenend) state=tail ;;
					"") ;;
					*)
						read -r t rest <<<"$line"
						case "$t" in
							header:) state=header; printf -v "header" "$i$i%s" "$rest" ;;
							footer:) state=footer; printf -v "footer" "$i$i%s" "$rest" ;;
							opt:) state=opt; idx=$(( $idx + 1 )); p_idx=0; on_opt_entered "$(printf "%03i" "$idx")" "$rest" ;;
						esac ;;
				esac ;;
			tail)
				case "$line" in
					@sogenend) state=tail ;;
					*) tail+=("$line") ;;
				esac ;;
			header)
				read -r t rest <<<"$line"
				case "$t" in
					:) printf -v "header" "%s\n${i}${i}%s" "$header" "$rest" ;;
					OPT|OPT:|opt|opt:) state=opt; idx=$(( $idx + 1 )); p_idx=0; on_opt_entered "$(printf "%03i" "$idx")" "$rest" ;;
					@sogenend) state=tail ;;
				esac ;;
			footer)
				read -r t rest <<<"$line"
				case "$t" in
					:) printf -v "footer" "%s\n${i}${i}%s" "$footer" "$rest" ;;
					OPT|OPT:|opt|opt:) state=opt; idx=$(( $idx + 1 )); p_idx=0; on_opt_entered "$(printf "%03i" "$idx")" "$rest" ;;
					@sogenend) state=tail ;;
				esac ;;
			opt)
				read -r t rest <<<"$line"
				case "$t" in
					OPT|OPT:|opt|opt:) idx=$(( $idx + 1 )); p_idx=0; on_opt_entered "$(printf "%03i" "$idx")" "$rest" ;;
					id) on_id "opt_$(printf "%03i" "$idx")" "$rest" ;;
					param|params) on_param "opt_$(printf "%03i" "$idx")" "$(printf "%03i" $p_idx)" "$rest"; p_idx=$(($p_idx+1)) ;;
					help) state=help; h_idx=0; on_help "opt_$(printf "%03i" "$idx")" "$(printf "%03i" $h_idx)" "$line" ;;
					header:) state=header; printf -v "header" "$i$i%s" "$rest" ;;
					footer:) state=footer; printf -v "footer" "$i$i%s" "$rest" ;;
					@sogenend) state=tail ;;
				esac ;;
			help)
				read -r t rest <<<"$line"
				case "$t" in
					:) h_idx=$(($h_idx+1)); on_help "opt_$(printf "%03i" "$idx")" "$(printf "%03i" $h_idx)" "$line" ;;
					param|params) on_param "opt_$(printf "%03i" "$idx")" "$(printf "%03i" $p_idx)" "$rest"; p_idx=$(($p_idx+1)) ;;
					OPT|OPT:|opt|opt:) state=opt; idx=$(( $idx + 1 )); p_idx=0; on_opt_entered "$(printf "%03i" "$idx")" "$rest" ;;
					header:) state=header; printf -v "header" "$i$i%s" "$rest" ;;
					footer:) state=footer; printf -v "footer" "$i$i%s" "$rest" ;;
					@sogenend) state=tail ;;
				esac ;;
			*) sogen_die "Unexpected state '$state'" ;;
		esac
	done
}

on_opt_entered() {
	local idx="$1" optline="$2" name= x= len= long= _long="opt_${1}_long" _short="opt_${1}_short" _name="opt_${1}_name"
	read -r o1 o2 x <<<"$optline"
	if [ "$x" ]; then
		sogen_die "'$optline' only two options allowed (long and short)"
	fi
	if [ ${#o1} -gt 1 ]; then
		printf -v "$_long" "%s" "$o1"
		if [ ${#o2} -eq 1 ]; then
			printf -v "$_short" "%s" "$o2"
		elif [ ${#o2} -gt 1 ]; then
			sogen_die "'$optline' - only one long option allowed"
		fi
	elif [ ${#o1} -eq 1 ]; then
		printf -v "${_short}" "%s" "$o1"
		if [ ${#o2} -gt 1 ]; then
			printf -v "$_long" "%s" "$o2"
		elif [ ${#o2} -eq 1 ]; then
			sogen_die "'$optline' - only one short option allowed"
		fi
	else
		sogen_die "'$optline' there must be at least one option (long or short)"
	fi
	# from now on we know that we have 1 or 2 option strings
	name="${!_long//-/_}"
	opts+=("$o1")
	if [ "${!_long}" ]; then
		name="${!_long//-/_}"
	else
		name="${!_short}"
	fi
	printf -v "${_name}" "$name"
	printf -v "opt_idx_${idx}" "%s" "${name}"
}

on_id() {
	printf -v "${1}_name" "${2}"
}

on_param() {
	local name= id= default= width= _opt_name="${1}_name"
	read -r name id default <<<"$3"
	if [[ -z "$id" ]]; then
		id="${!_opt_name}_${name}"
	fi
	_width="${1}_params_width"
	printf -v "${1}_params_${2}_id" "${id}"
	printf -v "${1}_params_${2}_default" "${default}"
	printf -v "${1}_params_${2}_marker" "${name}"
	printf -v "${1}_params_${2}_name" "${id//./${!_opt_name}}"
	printf -v "${1}_params_width" $((${!_width}+${#name}+1))
}

on_help() {
	printf -v "${1}_help_${2}" "${3}\n"
}

calc_helpindent() {
	local basenames= _bn= opt_idx= short= long= params= params_width= _long= _short= _id= _params_width= _help= len=

	basenames=(${!opt_idx_*})
	for _bn in "${basenames[@]}"; do
		opt_idx=${_bn#opt_idx_}
		_id="opt_${opt_idx}_name"
		_long="opt_${opt_idx}_long"
		_short="opt_${opt_idx}_short"
		_params="opt_${opt_idx}_params"
		_params_width="opt_${opt_idx}_params_width"

		short=${!_short}
		long=${!_long}
		params_width=${!_params_width}
		params=${!_params}

		if [[ ${short} && ${long} && ${params_width} -gt 0 ]]; then
			len=$((1 + ${#long} + ${params_width} + 4 + 1 ))
		elif [[ ${short} && ${long} ]]; then
			len=$((1 + ${#long} + 4 + 1))
		elif [[ ${short} && ${params_width} -gt 0 ]]; then
			len=$((1 + ${params_width} + 4 ))
		elif [[ ${short} ]]; then
			len=$((1 +  4 ))
		elif [[ ${long} && ${params_width} -gt 0 ]]; then
			len=$((1 + ${#long} + ${params_width} + 5 ))
		elif [[ ${long} ]]; then
			len=$((1 + ${#long} + 5 + 1))
		elif [[ ${params_width} -gt 0 ]]; then
			len=$((1 + ${params_width} + 5 ))
		else
			sogen_die "unexpected: there must be at least one of [short, long, params]"
		fi

		if [[ $len -gt $helpindent ]]; then
			helpindent=$len
		fi
	done
	helpindent=$((helpindent+1))
}

write_text() {
	local idt="$2" line=
	while read -r line; do
		if [[ "${line:0:1}" == "|" ]]; then
			echo "$idt${line#|}"
		else
			echo "$idt${line}"
		fi
	done <<<"$1"
	# echo "$1"
}

write_header() {
	if [ "$header" ]; then
		write_text "$header" "$i$i"
	fi
}

write_footer() {
	if [ "$footer" ]; then
		write_text "$footer" "$i$i"
	fi
}

write_help() {
	local basenames= _bn= opt_idx= long= _long= _short= _params= _help= gaplen
	local p_idx= h_idx= idx= prefix= rest=
	local param_names
	local _params_width params_width
	local _param param 
	echo "sogen_help() {"
	echo '	cat <<-"HELP"'
	write_header

	basenames=(${!opt_idx_*})
	for _bn in "${basenames[@]}"; do
		opt_idx=${_bn#opt_idx_}
		_long="opt_${opt_idx}_long"
		_short="opt_${opt_idx}_short"
		#_params="opt_${opt_idx}_params"
		_help="opt_${opt_idx}_help"
		_params_width="opt_${opt_idx}_params_width"


		short=${!_short}
		long=${!_long}
		params_width=${!_params_width}
		if [[ -z "$params_width" ]]; then
			params_width=1
		fi
		#params=${!_params}

		p_idx=0
		param_names=()
		while
			idx=$(printf "%03i" $p_idx)
			_param="opt_${opt_idx}_params_${idx}_marker"
			param=${!_param}
			[[ "$param" ]]
		do
			param_names+=($param)
			p_idx=$(($p_idx+1))
		done

		gaplen=$(($helpindent -${#long} - $params_width - 5))

		indentstr="$(printf ' %.0s' $(eval echo {1..$(($helpindent + 1))}))"
		shortdummy="$(printf ' %.0s' $(eval echo {1..4}))"

		printf "${i}${i}  "

		if [ ${!_short} ] && [ ${!_long} ]; then
			printf -- "-${!_short}, --${!_long}"
		elif [ ${!_short} ]; then # short only
			printf -- "-${!_short}"
			gaplen=$(($gaplen + 4))
		else # long only
			printf -- "$shortdummy--${!_long}"
		fi

		if [[ "${long}" && ${#param_names[@]} -eq 1 ]]; then
			printf -- "=%s" ${param_names[@]% }
		else
			printf -- " %s" ${param_names[@]% }
		fi

		printf -- "$(printf ' %.0s' $(eval echo {1..$gaplen}))"

		h_idx=0
		help_lines=()
		while
			idx=$(printf "%03i" $h_idx)
			_help="opt_${opt_idx}_help_${idx}"
			help=${!_help}
			[[ "$help" ]]
		do
			read -r prefix rest <<<"$help"
			help_lines+=($rest)
			if [ $h_idx -eq 0 ]; then
				write_text "${rest}"
			else
				printf "${i}${i}  ${indentstr}"
				write_text "${rest}"
			fi
			h_idx=$(($h_idx+1))
		done

		_help="opt_${opt_idx}_help_000"
		if [ -z "${!_help}" ]; then
			echo
		fi
	done

	write_footer
	echo "	HELP"
	echo '}'
}

write_init() {
	local basenames= _bn= 
	local opt_idx= idx= p_idx= 
	local _param= param= param_names= 
	local _param_id= _param_default= param_id= param_default= suffix=
	local name= _name= params= _params= idx=

	echo "sogen_init() {"
	basenames=(${!opt_idx_*})
	for _bn in "${basenames[@]}"; do
		opt_idx=${_bn#opt_idx_}
		_name="opt_${opt_idx}_name"
		name="${!_name}"
		_params="opt_${opt_idx}_params"
		params=(${!_params})

		p_idx=0
		param_names=()
		while
			idx=$(printf "%03i" $p_idx)
			_param="opt_${opt_idx}_params_${idx}_name"
			param=${!_param}
			[[ "$param" ]]
		do
			param_names+=($param)

			_param_id="opt_${opt_idx}_params_${idx}_id"
			param_id=${!_param_id}
			if [[ -z "$param_id" ]]; then
				param_id=$param
			fi

			_param_default="opt_${opt_idx}_params_${idx}_default"
			param_default="${!_param_default}"

			printf "${i}${param}=${!_param_default}\n"
			p_idx=$(($p_idx+1))
		done
		if [[ ${#param_names[@]} -eq 0 ]]; then
			echo "${i}$name="
		fi
	done
	echo "}"
}

write_dump() {
	local basenames= _bn= opt_idx= idx= p_idx= param_names= 
	local _param= param= param_names= 
	local name= _name= params= _params=
	local opt= _short= _long=

	echo "sogen_dump() {"
	basenames=(${!opt_idx_*})
	for _bn in "${basenames[@]}"; do
		opt_idx=${_bn#opt_idx_}
		_name="opt_${opt_idx}_name"
		_params="opt_${opt_idx}_params"
		name="${!_name}"
		params=(${!_params})
		_short="opt_${opt_idx}_short"
		_long="opt_${opt_idx}_long"
		opt=-${!_short}
		if [[ "${!_short}" ]]; then
			opt="-${!_short}"
			if [[ "${!_long}" ]]; then
				opt="-${!_short}, --${!_long}"
			fi
		elif [[ "${!_long}" ]]; then
			opt=--${!_long}
		else
			sogen_die "unexpectedly no option set"
		fi

		p_idx=0
		param_names=()
		while
			idx=$(printf "%03i" $p_idx)
			_param="opt_${opt_idx}_params_${idx}_name"
			param=${!_param}
			[[ "$param" ]]
		do
			param_names+=($param)
			printf "${i}echo \"%-24s %-24s '\${$param}'\"\n" "$opt:" "$param="
			p_idx=$(($p_idx+1))
		done
		if [[ ${#param_names[@]} -eq 0 ]]; then
			printf "${i}echo \"%-24s %-24s '\${$name}'\"\n" "$opt:" "$name="
		fi
	done
	cat <<-EOF
		${i}echo 'POSITIONAL ARGUMENTS:'
		${i}for a in "\$@"; do
		${i}${i}if [ "\${a// /}" == "\$a" ]; then
		${i}${i}${i}printf "%s " "\$a"
		${i}${i}else
		${i}${i}${i}printf "'%s' " "\$a"
		${i}${i}fi
		${i}done
		${i}echo
	EOF
	echo "}"
}

write_parser() {
	local basenames= _bn= opt_idx= idx= p_idx=0 params= param_names= param_markers= _long= _short= _name= _params=
	cat <<-EOF
		while :; do
		${i}case "\$1" in
	EOF

	basenames=(${!opt_idx_*})
	for _bn in "${basenames[@]}"; do
		opt_idx=${_bn#opt_idx_}
		_name="opt_${opt_idx}_name"
		_long="opt_${opt_idx}_long"
		_short="opt_${opt_idx}_short"
		_params="opt_${opt_idx}_params"
		name="${!_name}"
		params=(${!_params})


		if [[ "${!_short}" && "${!_long}" ]]; then
			echo "${i}${i}${i}-${!_short}|--${!_long})"
		elif [[ "${!_short}" ]]; then
			echo "${i}${i}${i}-${!_short})"
		elif [[ "${!_long}" ]]; then
			echo "${i}${i}${i}--${!_long})"
		fi

		# TODO: support new param approach

		p_idx=0
		param_names=()
		param_markers=()
		while
			idx=$(printf "%03i" $p_idx)
			_param="opt_${opt_idx}_params_${idx}_name"
			param=${!_param}
			_param_marker="opt_${opt_idx}_params_${idx}_marker"
			param_marker=${!_param_marker}
			[[ "$param" ]]
		do
			param_names+=($param)
			param_markers+=($param_marker)
			_param_default="opt_${opt_idx}_params_${idx}_default"
			param_default=${!_param_default}
			p_idx=$(($p_idx+1))
		done

		if [[ ${#param_names[@]} -eq 0 ]]; then
			echo "${i}${i}${i}${i}${name}=true"
			echo "${i}${i}${i}${i};;"
		else
			for idx in "${!param_names[@]}"; do
				cat <<-EOF
				${i}${i}${i}shift
				${i}${i}${i}[ "\$1" ] || sogen_die "--$name requires $(( ${#param_names[@]} - $idx )) more argument(s): ${param_markers[$idx]}"
				${i}${i}${i}printf -v "${param_names[idx]}" "\$1"
				EOF
			done
			echo "${i}${i}${i}${i};;"
			if [[ ${#param_names[@]} -eq 1 && "${!_long}" ]]; then
				cat <<-EOF
				${i}${i}--${!_long}=?*)
				${i}${i}${i}printf -v "${param_names[idx]}" "\${1#*=}"
				${i}${i}${i};;
				${i}${i}--${!_long}=)
				${i}${i}${i}[ "\$1" ] || sogen_die "--$name requires $(( ${#param_names[@]} - $idx )) more argument(s): ${param_markers[$idx]}"
				${i}${i}${i};;
				EOF
			fi
		fi
	done

	cat <<-EOF
		${i}${i}--?*)
		${i}${i}${i}sogen_die "unsupported option \$1"
		${i}${i}${i};;
		${i}${i}--)
		${i}${i}${i}shift
		${i}${i}${i}break
		${i}${i}${i};;
		${i}${i}-??*)
		${i}${i}${i}_sogen_mopt=\$1
		${i}${i}${i}shift
		${i}${i}${i}for (( i=((\${#_sogen_mopt}-1)); i>=1; i-- )); do
		${i}${i}${i}${i}set -- "-\${_sogen_mopt:\$i:1}" "\$@"
		${i}${i}${i}done
		${i}${i}${i}# unshift because the end of the loop will shift again:
		${i}${i}${i}set -- "\${_sogen_mopt}" "\$@"
		${i}${i}${i};;
		${i}${i}-?*)
		${i}${i}${i}sogen_die "unsupported option \$1"
		${i}${i}${i};;
		${i}${i}*)
		${i}${i}${i}break
		${i}${i}${i};;
		${i}esac
		${i}shift
		done

		if [ "\$sogen_help" ]; then
		${i}sogen_help
		${i}exit 0
		fi

		if [ "\$sogen_dump" ]; then
		${i}sogen_dump "\$@"
		${i}exit 0
		fi
	EOF
}

if [ "$sogen_help" ]; then
	sogen_help
	exit
fi

################################################################################
# Generated by sogen {

sogen_init() {
	sogen_help=
	sogen_dump=
	e=
	executable=
	indent="	"
}

sogen_help() {
	cat <<-"HELP"
		Usage: sogen [opt...] TEMPLATE
		
		sogen adds an option parser and a corresponding help function
		to a shell-script (TEMPLATE) that contains a sogen specification.
		
		
		Optional arguments:
		  -h, --help                 Display this help text and exit
		      --sogen-dump           Dump arguments and exit
		  -e                         Given an input-file named XXX.YYY
		                             the output will be written to XXX.sh
		                             and the file will be made executable
		      --executable=FILE      Write output to FILE and make the file executable
		  -i, --indent=INDENTSTRING  String for indenting the generated part of the script. E.g. $'\t' or "    "
		                             This helps to keep indentation in the generated script consistent.
		                             Mind that for tabs you have to use the single-quote bash form as you see below.
		                             DEFAULT: $'\t'
		
		
		A sogen specification has the following format (EBNF):
		
		sogendef   ::= '@sogenstart' '\n' header? option* footer? '@sogenend' '\n'
		header     ::= 'header' ':' textlines
		footer     ::= 'footer' ':' textlines
		option     ::= optdef (idddef? paramdef* helpdef?) '\n'*
		optdef     ::= ('OPT' | 'opt') ':'? '[[:blank:]]+' (shortlong) '[[:blank:]]*' '\n'
		idddef     ::= 'id' '[[:blank:]]+' ID '[[:blank:]]*' '\n'
		paramdef   ::= 'param' '[[:blank:]]'+ pdef '[[:blank:]]'* '\n'
		helpdef    ::= 'help' textlines
		
		textlines  ::= '[[:blank:]]+' TEXT '\n' (':' '[[:blank:]]+' TEXT '\n')*
		shortlong  ::= (SHORT LONG) | (LONG SHORT) | SHORT | LONG
		pdef       ::= PNAME ('[[:blank:]]+' ID ('[[:blank:]]+' DEFAULT)?)?
		
		SHORT      ::= '[[:lower:]]'
		LONG       ::= '[[:lower:]]'+ ('-' '[[:lower:]]'+)+
		PNAME      ::= '[[:upper:]]'+
		ID         ::= '[_[:alpha:]]' '[_[:alnum:]]'* | '.'
		DEFAULT    ::=  TEXT
		TEXT       ::= '[^\n]*'
		
	HELP
}

sogen_dump() {
	echo "-h, --help:              sogen_help=              '${sogen_help}'"
	echo "--sogen-dump:            sogen_dump=              '${sogen_dump}'"
	echo "-e:                      e=                       '${e}'"
	echo "--executable:            executable=              '${executable}'"
	echo "-i, --indent:            indent=                  '${indent}'"
	echo 'POSITIONAL ARGUMENTS:'
	for a in "$@"; do
		if [ "${a// /}" == "$a" ]; then
			printf "%s " "$a"
		else
			printf "'%s' " "$a"
		fi
	done
	echo
}

sogen_die() {
    echo "ERROR: $1" >&2
    echo >&2
    sogen_help >&2
    exit 1
}
sogen_init

while :; do
	case "$1" in
			-h|--help)
				sogen_help=true
				;;
			--sogen-dump)
				sogen_dump=true
				;;
			-e)
				e=true
				;;
			--executable)
			shift
			[ "$1" ] || sogen_die "--executable requires 1 more argument(s): FILE"
			printf -v "executable" "$1"
				;;
		--executable=?*)
			printf -v "executable" "${1#*=}"
			;;
		--executable=)
			[ "$1" ] || sogen_die "--executable requires 1 more argument(s): FILE"
			;;
			-i|--indent)
			shift
			[ "$1" ] || sogen_die "--indent requires 1 more argument(s): INDENTSTRING"
			printf -v "indent" "$1"
				;;
		--indent=?*)
			printf -v "indent" "${1#*=}"
			;;
		--indent=)
			[ "$1" ] || sogen_die "--indent requires 1 more argument(s): INDENTSTRING"
			;;
		--?*)
			sogen_die "unsupported option $1"
			;;
		--)
			shift
			break
			;;
		-??*)
			_sogen_mopt=$1
			shift
			for (( i=((${#_sogen_mopt}-1)); i>=1; i-- )); do
				set -- "-${_sogen_mopt:$i:1}" "$@"
			done
			# unshift because the end of the loop will shift again:
			set -- "${_sogen_mopt}" "$@"
			;;
		-?*)
			sogen_die "unsupported option $1"
			;;
		*)
			break
			;;
	esac
	shift
done

if [ "$sogen_help" ]; then
	sogen_help
	exit 0
fi

if [ "$sogen_dump" ]; then
	sogen_dump "$@"
	exit 0
fi

# End of sogen-generated code }
################################################################################

main "$@"
